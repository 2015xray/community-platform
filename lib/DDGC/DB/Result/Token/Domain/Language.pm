package DDGC::DB::Result::Token::Domain::Language;

use DBIx::Class::Candy -components => [ 'TimeStamp', 'InflateColumn::DateTime', 'InflateColumn::Serializer', 'EncodedColumn' ];
use File::Spec;
use File::Which;
use IO::All -utf8;
use Path::Class;
use Carp;
use DateTime;
use DateTime::Format::Strptime;

table 'token_domain_language';

column id => {
	data_type => 'bigint',
	is_auto_increment => 1,
};
primary_key 'id';

column language_id => {
	data_type => 'bigint',
	is_nullable => 0,
};

column token_domain_id => {
	data_type => 'bigint',
	is_nullable => 0,
};

column created => {
	data_type => 'timestamp with time zone',
	set_on_create => 1,
};

column updated => {
	data_type => 'timestamp with time zone',
	set_on_create => 1,
	set_on_update => 1,
};

belongs_to 'token_domain', 'DDGC::DB::Result::Token::Domain', 'token_domain_id';
belongs_to 'language', 'DDGC::DB::Result::Language', 'language_id';

has_many 'token_languages', 'DDGC::DB::Result::Token::Language', 'token_domain_language_id';

sub insert {
	my $self = shift;
	my $guard = $self->result_source->schema->txn_scope_guard;
	$self->next::method(@_);
	for ($self->token_domain->tokens->all) {
		$self->create_related('token_languages',{
			token_id => $_->id,
		});
	}
	$guard->commit;
	return $self;
}

sub generate_po_for_locale_in_dir_as_with_fallback {
	my ( $self, $basedir, $generator, $fallback ) = @_;
	my $locale = $self->language->locale;
	my $key = $self->token_domain->key;
	my $dt = DateTime->now(
		locale => 'en_US',
		time_zone => 'Pacific/Easter',
	);
	my $datestring = DateTime::Format::Strptime->new(
		pattern => '%F %R%z',
	)->format_datetime($dt);
	my $lang = $self->language->name_in_english;
	my $lang_loc = $self->language->name_in_local;
	my $plural_forms = $self->language->plural_forms;
	my $po_filename = $basedir->file($key.'.po')->absolute;
	my $mo_filename = $basedir->file($key.'.mo')->absolute;
	my $js_filename = $basedir->file($key.'.js')->absolute;
	my $po = io($po_filename);
	my $intro = << "EOF";
#
# Autogenerated by $generator
#
# language: $lang
# locale: $locale
# date: $datestring
#
msgid ""
msgstr ""
"Project-Id-Version: DuckDuckGo-Translation-0.000\\n"
"Last-Translator: Community\\n"
"Language-Team: DuckDuckGo Community <community\@duckduckgo.com>\\n"
"POT-Creation-Date: $datestring\\n"
"PO-Revision-Date: $datestring\\n"
"Language: $lang_loc ($lang)\\n"
"MIME-Version: 1.0\\n"
"Content-Type: text/plain; charset=UTF-8\\n"
"Content-Transfer-Encoding: 8bit\\n"
"Plural-Forms: $plural_forms\\n"

EOF
	$intro > $po;
	my %doublecheck;
	for ($self->search_related('token_languages')->all) {
		$_->auto_use; # should be renamed
		my $msgid = $_->token->msgid;
		$msgid .= '||||msgctxt||||'.$_->token->msgctxt if $_->token->msgctxt;
		my $tid = $_->token->id;
		if (defined $doublecheck{$msgid}) {
			warn 'Token #'.$tid.' is a double of Token #'.$doublecheck{$msgid}.', I will ignore it';
		} else {
			$doublecheck{$msgid} = $tid;
			$_->gettext_snippet($fallback) >> $po;
		}
	}
	die "msgfmt failed" if system("msgfmt -c ".$po_filename." -o ".$mo_filename);
	io($js_filename)->print("\nlocale_data['".$key."'] = ");
	die "po2json failed" if system("po2json ".$po_filename." >> ".$js_filename);
	io($js_filename)->append(";\n");
}

use overload '""' => sub {
	my $self = shift;
	return 'Token-Domain-Language for '.$self->token_domain->key.' with locale '.$self->language->locale;
}, fallback => 1;

1;
